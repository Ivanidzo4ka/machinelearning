// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using Microsoft.ML.Data.StaticPipe.Runtime;

namespace Microsoft.ML.Runtime.Data
{
    public static partial class CategoricalStaticExtensions
    {
        // Do not edit this file directly. Rather, it is generated out of TermStaticExtensions.tt.

        #region For string inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<string> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<string> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<string> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, string> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, string>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because the empty string is never entered into the dictionary, it will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, string>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<string>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For float inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<float> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<float> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<float> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, float> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, float>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, float>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<float>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For double inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<double> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<double> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<double> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, double> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, double>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Because <c>NaN</c> floating point values are never entered into the dictionary, and they will always map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, double>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<double>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For sbyte inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<sbyte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<sbyte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<sbyte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, sbyte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, sbyte>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, sbyte>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<sbyte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For short inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<short> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<short> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<short> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, short> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, short>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, short>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<short>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For int inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<int> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<int> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<int> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, int> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, int>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, int>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<int>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For long inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<long> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<long> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<long> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, long> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, long>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, long>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<long>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For byte inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<byte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<byte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<byte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, byte> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, byte>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, byte>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<byte>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For ushort inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<ushort> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<ushort> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<ushort> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, ushort> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, ushort>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, ushort>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<ushort>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For uint inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<uint> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<uint> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<uint> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, uint> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, uint>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, uint>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<uint>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For ulong inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<ulong> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<ulong> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// Zero is considered a valid value and so will be entered into the dictionary if observed. The potential perf
        /// implication in that case is that sparse input numeric vectors will map to dense output key vectors.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<ulong> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, ulong> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, ulong>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, ulong>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<ulong>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion

        #region For bool inputs.
        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Scalar<bool> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding(this Vector<bool> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding(this VarVector<bool> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Key<T, bool> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplScalar<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static Vector<float> OneHotEncoding<T>(this Vector<Key<T, bool>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));

        /// <summary>
        /// Map values to a key-value representation, where the key type's values are those values observed in the input
        /// during fitting. During transformation, any values unobserved during fitting will map to the missing key.
        /// We are inputting a key type with values, and in that case the dictionary is considered to be built over the
        /// values of the keys, rather than the keys themselves. This also mean the key-values learned for the output
        /// will be a subset of the key-values in the input.
        /// </summary>
        /// <param name="input">The input column.</param>
        /// <param name="outputKind"></param>
        /// <param name="order">The ordering policy for what order values will appear in the enumerated set.</param>
        /// <param name="maxItems">The maximum number of items.</param>

        /// <returns>The key-valued column.</returns>
        public static VarVector<float> OneHotEncoding<T>(this VarVector<Key<T, bool>> input,
                OneHotOutputKind outputKind = DefOut, KeyValueOrder order = DefSort, int maxItems = DefMax)
            => new ImplVarVector<bool>(Contracts.CheckRef(input, nameof(input)), new Config(order, maxItems, outputKind));
        #endregion
    }
}